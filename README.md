# 엘레강트 오브젝트

## 1장 출생

* 1.1 -er로 끝나는 이름을 사용하지 마세요
  * er 끝나는 이름은 왜 안 좋은가요?
    * er로 붙이면 자체로 무엇을 하는지를 드러내기 때문에 사용하면 안좋다.
    * 객체는 객체의 외부 세계와 내부 세계를 이어주는 연결장치가 아니다.
  * 올바른 클래스 이름은 어떻게 짓는 게 좋은가요?
    * 클래스의 이름을 무엇을 한다가 아니라 무엇인지 이름을 붙여야한다.
* 1.2 생성자 하나를 주 생성자로 만드세요
  * 프로퍼티는 오직 한 곳에서만 초기화해야 하는 이유는 무엇인가요?
    * 여러가지 타입이 와도 유연하게 대체할 수 있게 하기 위해서
    * 프로퍼티를 한 곳에서만 초기화하고 함으로써 복잡성을 줄이고 중복을 제거하기 위해서.
* 1.3 생성자에 코드를 넣지 마세요
  * 생성자에 코드를 넣지 말아야 하는 이유는?
    * 성능최적화가 어렵다
    * 예측하기 힘들다
    * 리팩터링하기 어려워진다.

## 2장 학습

* 2.1 가능하면 적게 캡슐화하세요
  * 적게 캡슐화를 해야하는 이유는 무엇인가요?
    * 4개 이하로 해라.
    * 직관에 위배된다.
    * 캡슐화를 하는 것이 식별자를 만드는데, 너무 많아지면 객체를 이해하기 어려워진다.
* 2.2 최소한 뭔가는 캡슐화하세요
  * 어떤 것도 캡슐화되어 있지 않은 객체는 왜 쓸모없는가?
* 2.3 항상 인터페이스를 사용하세요
  * 결합이란게 왜 생기나요?
    * 클래스가 다른 클래스와 협력을 했을 때 결합이 생긴다.
  * 결합을 왜 느슨하게 해야되는가?
    * 객체들이 강하게 결합되어 있으면 변경사항이 다른 객체들에게까지 영향을 미친다.
  * 인터페이스란 무엇인가?
    * 함수의 Signature의 모음
    * 메서드의 이름, 입력값들, 반환값 => signature
  * 인터페이스를 사용하여 어떻게 구체적인 클래스와의 결합을 느슨하게 할 수 있는가?
    * 인터페이스의 의존하게되면 구체적인 객체에 의존하지 않고 협력할 수 있다.
    * 인터페이스에 의존하면, 인터페이스를 구현하는 다른 객체로 쉽게 대체가 가능하다.
* 2.4 메서드 이름을 신중하게 선택하세요
  * 빌더가 명사인 이유는 무엇인가?
    * 객체에게 원하는 것만 요구할 뿐이지, 어떻게 기술하지 않는다.
  * 조정자가 동사인 이유는 무엇인가?
    * 조정자는 객체를 변경할 때 사용한다.
    * 동작을 기술해야하기 때문이다.
  * 조정자는 왜 반환값이 없어야 한다고 했는가?
    * 행동에 의해 변경이 일어날 뿐이다.
* 2.5 퍼블릭 상수(public constant)를 사용하지 마세요
  * 퍼블릭 상수를 사용하지 않아야하는 이유는 무엇인가요?
* 2.6 불변 객체로 만드세요
  * 가변클래스보다 불변클래스로 만들어야하는 이유는 무엇인가요?
  * 가변클래스가 안좋은 사례를 들어주세요
* 2.7 문서를 작성하는 대신 테스트를 만드세요
  * 문서 대신 테스트를 만들어야 하는 이유는?
* 2.8 모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요
  * 모의 객체 대신 페이크 객체를 사용해야 하는 이유는 무엇인가요?
    * 리팩터링 하기 힘들다.
    * 수정하기 힘들다.
    * 모의 객체를 사용하게되면, 객체가 실제로 무슨 일을 하는지 드러난다.
    * 모킹은 클래수 구현과 관련된 내부의 세부사항을 테스트와 결합시킨다.
    * 테스트 객체 내부의 구현 세부사항을 알면 테스트가 취약해지고 유지보수하기 어려워진다.

```java
// Mock
Exchange exchange = Mockito.mock(Exchange.class);
Mockito.doReturn(1.15)
  .when(exchange)
  .rate("KRW", "EUR");

// Fake
Exchange exchange = new Exchange.Fake();
Cash dollar = new Cash(exchange, 500);
```

* 2.9 인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요
  * 스마트를 사용해야 하는 이유는 무엇인가?
    * 공통 기능을 추출하고, 코드 중복을 피하기 위해서 사용한다.
    * 다른 대안도 있을까?
      * Default method는 안되나?
      * Factory method패턴은 안되나?
      * 데코레이터로는 안되나?

## 3장 취업

* 3.1 5개 이하의 public 메서드만 노출하세요
  * 객체를 작게 유지해야 하는 이유는?
    * 유지보수하기 쉽게 하기 위해서 - 속성과 메서드가 긴밀하게 관계를 가질 가능성이 높다. => 응집도를 높이기 위해서
    * 테스트하기 쉽다. - 여러 기능이 있으면 테스트가 점점 어려워진다.
* 3.2 정적 메서드를 사용하지 마세요
  * 정적메서드는 왜 사용하면 안되는가? => 유지보수하기 어렵다.
    * Procedural programming처럼 작성하게 된다.
    * 선언형이 아니라 명령형으로 프로그래밍을 작성하게 된다.
    * 조합이 불가능하다.
  * 왜 선언형으로 작성해야 하는가?
    * 성능 최적화가 쉽다
    * 다형성
    * 표현력이 좋다
    * 코드 응집도
* 3.3 인자의 값으로 NULL을 절대 허용하지 마세요
  * NULL을 허용하지 않아야 하는 이유는?
    * NULL을 허용할 경우 객체를 살아있는 유기체로 바라보지 않는다. 객체가 자신의 책임을 온전히 지도록 할 수 없다. 이미 NULL일 경우에는 객체가 스스로 책임을 수행할 수 없다.
* 3.4 충성스러우면서 불변이거나, 아니면 상수이거나
* 3.5 절대 getter와 setter를 사용하지 마세요
  * 자료구조와 객체의 차이점은?
    * getter와 setter만 있는 객체 사용하면 안된다. => 자료구조
    * 객체는 데이터에 직접 접근하는 것이 아니라, 우리가 메세지를 협력하는 것.
* 3.6 부 ctor 밖에서는 new를 사용하지 마세요
  * 부 생성자 밖에서 new를 사용하지 말아야 하는 이유는?
    * 객체 사이의 의존성이 생긴다. => 의존성 주입으로 해결.
    * 기대하지 않았던 것을 하게 된다.
* 3.7 인트로스펙션과 캐스팅을 피하세요
  * 인트로스펙션과 캐스팅을 피해야하는 이유는?

## 4장 은퇴

* 4.1 절대 NULL을 반환하지 마세요
  * NULL을 반환하지 말아야 하는 이유는?
* 4.2 체크 예외(checked exception)만 던지세요
  * 예외처리는 어떻게 해야 하는가?
* 4.3 final이거나 abstract이거나
  * 클래스를 상속하지 못하도록 하려면 어떻게 해야하는가?
* 4.4 RAII를 사용하세요
  * RAII는 무엇인가?

## Sources

* 엘레강트 오브젝트 - 교보문고 - http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9791187497219
